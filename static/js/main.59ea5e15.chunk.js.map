{"version":3,"sources":["App.js","serviceWorker.js","index.js","components/game.jsx"],"names":["App","className","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","KEY","LEFT","RIGHT","UP","DOWN","maxSize","Game","canvasRef","React","createRef","state","ship","x","y","width","height","bullets","score","highScore","touchStart","undefined","draw","bind","startGame","addEventListener","this","handleKeys","handleTouchStart","handleTouchEnd","clearInterval","accelerateInterval","generationInterval","updateInterval","detectionInterval","setState","setInterval","accelerateGame","generationIntervalDuration","generateNewBullet","updateIntervalDuration","updateBullets","detectCollisions","context","current","getContext","clearRect","fillStyle","fillRect","i","length","bullet","value","event","keyCode","moveHorizontally","moveVertically","changedTouches","currentTouch","deltaX","Math","abs","clientX","deltaY","clientY","reduce","filtered","axis","nextFrame","push","round","random","direction","eval","forEach","style","position","overflow","ref","border","Component"],"mappings":"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","file":"static/js/main.59ea5e15.chunk.js","sourcesContent":["import React from 'react';\n\nimport './App.css';\nimport Game from './components/game';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Game/>\n\n      {/*<header className=\"App-header\">\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\n        <p>\n          Edit <code>src/App.js</code> and save to reload.\n        </p>\n        <a\n          className=\"App-link\"\n          href=\"https://reactjs.org\"\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n        >\n          Learn React\n        </a>\n  </header>*/}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React, {Component} from 'react';\n\nconst KEY = { //Keyboard key codes\n    LEFT: 37,\n    RIGHT: 39,\n    UP: 38,\n    DOWN: 40\n}\n\nconst maxSize = 260 //size of the board\n\nclass Game extends Component {\n\n    constructor() {\n        super();\n        this.canvasRef = React.createRef();\n        this.state = {\n            ship: {\n                x: 120,\n                y: 120,\n                width: 20,\n                height: 20\n            },\n            bullets: [],\n            score: 0,\n            highScore: 0,\n            touchStart: undefined\n        }\n        this.draw = this.draw.bind(this)\n        this.startGame = this.startGame.bind(this)\n    }\n\n    componentDidMount() {\n        window.addEventListener('keydown', this.handleKeys.bind(this, true)); //add a listener for the keydown event\n        //window.addEventListener('touchmove', this.handleTouch.bind(this, false)) //add a listener \n        window.addEventListener('touchstart', this.handleTouchStart.bind(this, false)) //add a listener \n        window.addEventListener('touchend', this.handleTouchEnd.bind(this, false)) //add a listener \n        this.startGame(); //begin the game!\n    }\n\n    componentWillUnmount() {\n        //remove all intervals\n        clearInterval(this.accelerateInterval); \n        clearInterval(this.generationInterval);\n        clearInterval(this.updateInterval);\n        clearInterval(this.detectionInterval);\n    }\n    /**\n     * Begin the game, reset state and initialize intervals\n     */\n    startGame() {\n        this.setState({\n            ship: {\n                x: 120,\n                y: 120,\n                width: 20,\n                height: 20\n            },\n            bullets: [],\n            score: 0\n        }), () => {\n            this.draw()\n        }\n        this.accelerateInterval = setInterval(() => this.accelerateGame(), 7500)\n        this.generationIntervalDuration = 1000\n        this.generationInterval = setInterval(() => this.generateNewBullet(), this.generationIntervalDuration)\n        this.updateIntervalDuration = 25\n        this.updateInterval = setInterval(() => this.updateBullets(), this.updateIntervalDuration)\n        this.detectionInterval = setInterval(() => this.detectCollisions(), 5)\n    }\n\n    /**\n     * draws the elements on the canvas\n     */\n    draw() {\n        const context = this.canvasRef.current.getContext(\"2d\");\n        context.clearRect(0, 0, this.canvasRef.current.width, this.canvasRef.current.height); //clear it first\n        context.fillStyle = \"blue\"; //use the color blue\n        context.fillRect(this.state.ship.x, this.state.ship.y, this.state.ship.width, this.state.ship.height); //draw the player's rectangle\n        for(let i = 0; i < this.state.bullets.length; i++) { //draw the bullets (in red this time!)\n            let bullet = this.state.bullets[i]\n            context.fillStyle = \"red\";\n            context.fillRect(bullet.x, bullet.y, bullet.width, bullet.height)\n        }\n    }\n    \n    /**\n     * Event handler for key down\n     * @param value\n     * @param event \n     */\n    handleKeys(value, event) {\n        if(event.keyCode === KEY.LEFT) this.moveHorizontally(-20)\n        if(event.keyCode === KEY.RIGHT) this.moveHorizontally(20)\n        if(event.keyCode === KEY.UP) this.moveVertically(-20)\n        if(event.keyCode === KEY.DOWN) this.moveVertically(20)\n    }\n\n    /**\n     * Event handler for touch start\n     * @param value\n     * @param event \n     */\n    handleTouchStart(value, event) {\n        this.setState({touchStart: event.changedTouches[0]})\n    }\n    \n    /**\n     * Event handelr for touch end\n     * @param value\n     * @param event \n     */\n    handleTouchEnd(value, event) {\n        if(this.state.touchStart !== undefined) {\n            let currentTouch = event.changedTouches[0]\n            let touchStart = this.state.touchStart\n            let deltaX = Math.abs(touchStart.clientX - currentTouch.clientX)\n            let deltaY = Math.abs(touchStart.clientY - currentTouch.clientY)\n            \n            if(deltaX > deltaY) {\n                touchStart.clientX > currentTouch.clientX ? this.moveHorizontally(-20) : this.moveHorizontally(20)\n            } else if (deltaX < deltaY) {\n                touchStart.clientY > currentTouch.clientY ? this.moveVertically(-20): this.moveVertically(20)\n            }\n            this.setState({touchStart: currentTouch})\n        }\n    }\n\n    /**\n     * Function to move the player horizontally\n     * @param value \n     */\n    moveHorizontally(value) {\n        let ship = this.state.ship\n        if(ship.x + value <= (maxSize - 20) && ship.x + value >= 0) {\n            ship.x += value \n            this.setState({ship: ship}, () => this.draw())\n        }\n    }\n\n    /**\n     * Function to move the player vertically\n     * @param value \n     */\n    moveVertically(value) {\n        let ship = this.state.ship\n        if(ship.y + value <= (maxSize - 20) && ship.y + value >= 0) {\n            ship.y += value \n            this.setState({ship: ship}, () => this.draw())\n        }\n    }\n\n    /**\n     * Function to update the position of the bullets (in other words make them move)\n     */\n    updateBullets() {\n        let bullets = this.state.bullets.reduce((filtered, bullet) => {\n            if(bullet[bullet.axis] >= -20 && bullet[bullet.axis] <= maxSize) { //if the bullet trespass the game boundaries, do not store it again\n                bullet.nextFrame()\n                filtered.push(bullet)\n            } else { //which also means you get a point on the score\n                this.setState({score: this.state.score + 1})\n            }\n            return filtered\n        }, [])\n        this.setState({bullets: bullets}, () => { //update bullets in state and redraw the canvas\n            this.draw()\n        })\n    }\n\n    /**\n     * Function to generate new bullets\n     */\n    generateNewBullet() { \n        let bullet = {\n            axis: Math.round(Math.random()) ? 'x' : 'y', //if random number == 1 the bullet will move on x axis, \n            direction: Math.round(Math.random()) ? '+' : '-', //if random number == 1 the bullet will go positive\n            width: 20,\n            height: 20\n        }\n        if(bullet.axis === 'x') { //if the bullet moves along the x axis, use the y position of the player as fixed axis\n            bullet.y = this.state.ship.y\n            bullet.direction === '+' ? bullet.x = -20 : bullet.x = maxSize //the starting position is depend from the direction\n        } else { //if the bullet moves along the y axis, use the x position of the player as fixed axis\n            bullet.x = this.state.ship.x \n            bullet.direction === '+' ? bullet.y = -20 : bullet.y = maxSize //the starting position is depend from the direction\n        }\n        /**\n         * Function to move to the bullet's next position\n         */\n        bullet.nextFrame = () => {\n            bullet[bullet.axis] = eval(bullet[bullet.axis] + bullet.direction + \"2\")\n        }\n        this.setState({bullets: [... this.state.bullets, bullet]}) //update the state\n    }\n\n    /**\n     * Function to detect collisions\n     */\n    detectCollisions() { \n        \n        this.state.bullets.forEach(bullet => { //check for each bullet if the rectangle collides with the player's rectangle\n            if(bullet.x < this.state.ship.x + this.state.ship.width &&\n                bullet.x + bullet.width > this.state.ship.x &&\n                bullet.y < this.state.ship.y + this.state.ship.height &&\n                bullet.y + bullet.width > this.state.ship.y) {\n                    //if it does, clear intervals, save highscore and restart the game\n                    clearInterval(this.accelerateInterval)\n                    clearInterval(this.updateInterval)\n                    clearInterval(this.generationInterval)\n                    clearInterval(this.detectionInterval)\n                    this.state.score > this.state.highScore ? this.setState({highScore: this.state.score}, () => {this.startGame()}) : this.startGame()\n            }\n        })\n    }\n\n    /**\n     * Function to make bullets being spawned faster with higher velocity\n     */\n    accelerateGame() {\n        clearInterval(this.updateInterval)\n        this.updateIntervalDuration = Math.round(this.updateIntervalDuration/1.2)\n        this.updateInterval = setInterval(() => this.updateBullets(), this.updateIntervalDuration)\n\n        clearInterval(this.generationInterval)\n        this.generationIntervalDuration = Math.round(this.generationIntervalDuration/1.2)\n        this.generationInterval = setInterval(() => this.generateNewBullet(), this.generationIntervalDuration)\n        \n    }\n\n    render() {\n        return (\n            <div style={{position: 'fixed', height: '100%', overflow: 'hidden', width: '100%'}}>\n                <h4>Use arrows to move</h4>\n                <canvas ref={this.canvasRef} width={maxSize} height={maxSize} style={{border: \"1px solid black\"}} />\n                <br/>\n                Score: {this.state.score*10} | Highscore: {this.state.highScore*10}\n            </div>\n        );\n    }\n}\n\nexport default Game;"],"sourceRoot":""}